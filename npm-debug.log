0 info it worked if it ends with ok
1 verbose cli [ 'C:\\Program Files\\nodejs\\node.exe',
1 verbose cli   'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
1 verbose cli   'publish' ]
2 info using npm@3.10.10
3 info using node@v6.11.5
4 verbose publish [ '.' ]
5 silly cache add args [ '.', null ]
6 verbose cache add spec .
7 silly cache add parsed spec Result {
7 silly cache add   raw: '.',
7 silly cache add   scope: null,
7 silly cache add   escapedName: null,
7 silly cache add   name: null,
7 silly cache add   rawSpec: '.',
7 silly cache add   spec: 'D:\\dev\\node_modules\\hooks',
7 silly cache add   type: 'directory' }
8 verbose addLocalDirectory C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package.tgz not in flight; packing
9 verbose correctMkdir C:\Users\Mark Dekin\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
10 verbose makeDirectory C:\Users\Mark Dekin\AppData\Roaming\npm-cache creation not in flight; initializing
11 verbose makeCacheDir UID & GID are irrelevant on win32
12 info lifecycle hooks@0.1.0~prepublish: hooks@0.1.0
13 silly lifecycle hooks@0.1.0~prepublish: no script for prepublish, continuing
14 verbose tar pack [ 'C:\\Users\\Mark Dekin\\AppData\\Roaming\\npm-cache\\hooks\\0.1.0\\package.tgz',
14 verbose tar pack   'D:\\dev\\node_modules\\hooks' ]
15 verbose tarball C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package.tgz
16 verbose folder D:\dev\node_modules\hooks
17 verbose addLocalTarball adding from inside cache C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package.tgz
18 verbose correctMkdir C:\Users\Mark Dekin\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
19 silly cache afterAdd hooks@0.1.0
20 verbose afterAdd C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package\package.json not in flight; writing
21 verbose correctMkdir C:\Users\Mark Dekin\AppData\Roaming\npm-cache correctMkdir not in flight; initializing
22 verbose afterAdd C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package\package.json written
23 silly publish { name: 'hooks',
23 silly publish   version: '0.1.0',
23 silly publish   description: 'create hookable objects',
23 silly publish   main: 'index.js',
23 silly publish   scripts: { test: 'echo "Error: no test specified" && exit 1' },
23 silly publish   repository:
23 silly publish    { type: 'git',
23 silly publish      url: 'git+https://github.com/Secular12/hooks.git' },
23 silly publish   keywords: [ 'hooks', 'hook', 'hookable' ],
23 silly publish   author: { name: 'Mark Dekin' },
23 silly publish   license: 'ISC',
23 silly publish   bugs: { url: 'https://github.com/Secular12/hooks/issues' },
23 silly publish   homepage: 'https://github.com/Secular12/hooks#readme',
23 silly publish   readme: '# HookGroups Class\r\n\r\n## Table of Contents\r\n- [Set Up](#set-up)\r\n\t- [Set Up Example](#appjs)\r\n- [Initiatizing](#initializing)\r\n- [Hook Group vs. Hook](#hook-group-vs-hook)\r\n- [Creating Hooks](#creating-hooks)\r\n\t- [.hook()](#hook)\r\n\t- [.hookGroup()](#hookgroup)\r\n- [Running Hooks](#running-hooks)\r\n\t- [.runHooks()](#runhooks)\r\n- [Getting Hooks](#getting-hooks)\r\n\t- [.getHook()](#gethook)\r\n\t- [.getHookGroup()](#gethookgroup)\r\n\t- [.getHooks()](#gethooks)\r\n- [Removing Hooks](#removing-hooks)\r\n\t- [.unhook()](#unhook)\r\n\t- [.unhookGroup()](#unhookgroup)\r\n\t- [.unhookAll()](#unhookall)\r\n- [Cloning Hooks](#cloning-hooks)\r\n\t- [.cloneHook()](#clonehook)\r\n\t- [.cloneHookGroup()](#clonehookgroup)\r\n- [Altering Hooks](#altering-hooks)\r\n\t- [.moveHook()](#movehook)\r\n\t- [.swapHooks()](#swaphooks)\r\n\t- [.hookGroupSync()](#hookgroupsync)\r\n\t- [.cleanHookGroup()](#cleanhookgroup)\r\n\t- [.cleanHooks()](#cleanhooks)\r\n\r\n## Set Up\r\nGeneral set up would include file(s) dedicated to editing hooks, a file to create a hook-able object that defines the method(s) which use/include the hooks, and finally the file(s) of the app, which call in and use the hooked object.\r\n\r\nHere is an example of a basic set up to creating a hook-able object which runs express, and allows developers to hook before and after the initializing of express and even change the port from a separate file.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### App.js\r\n\r\n```javascript\r\nconst express = require(\'express\');\r\nconst HookGroups = require(\'./HookGroups\');\r\nconst App = new Hooks();\r\n\r\nApp.exp = express();\r\n\r\nApp.hook(\'setport\', \'sets port to 3000\', () => {\r\n    new Promise((res, rej) => {\r\n        App.data.portListen = 3000;\r\n        res(\'done\');\r\n    });\r\n});\r\n\r\nApp.init = () => {\r\n    App.runHooks(\'setport\')\r\n    .then(\r\n        done => {\r\n            return App.runHooks(\'preinit\');\r\n        }\r\n    ).then(\r\n        done => {\r\n            return new Promise((res, rej) => {\r\n                App.exp.listen(App.data.portListen, App.runHooks(\'postinit\'));\r\n            });\r\n        }\r\n    ).catch(\r\n        error => {\r\n            console.error(error);\r\n        }\r\n    );\r\n}\r\n\r\nmodule.exports = App;\r\n```\r\n\r\n### hooks.js\r\n\r\n```javascript\r\nconst App = require(\'./App\');\r\n\r\nexports.hooks = () => {\r\n  App.hook(\'setport\', \'sets port to 4000\', () => {\r\n      new Promise((res, rej) => {\r\n          App.data.portListen = 4000;\r\n          res(\'done\');\r\n      });\r\n  }, 0, true);\r\n\r\n  App.hook(\'preinit\', \'logs that init is about to start\', () => {\r\n      new Promise((res, rej) => {\r\n          console.log(`About to listen to port ${App.data.portListen}`);\r\n          res(\'done\');\r\n      });\r\n  });\r\n\r\n  App.hook(\'postinit\', \'logs that now listening\', () => {\r\n      new Promise((res, rej) => {\r\n          console.log(`Now listening to port ${App.data.portListen}...`);\r\n          res(\'done\');\r\n      });\r\n  });\r\n};\r\n```\r\n\r\n### index.js\r\n\r\n```javascript\r\nconst App = require(\'./App\');\r\nconst {hooks} = require(\'./hooks\');\r\n\r\nhooks();\r\nApp.init();\r\n```\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Initializing\r\nMake a new instance of a the HookGroups Class.\r\n\r\n  ```javascript\r\n  const TestHooks = new Hooks();\r\n  ```\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Hook Group vs. Hook\r\nA HookGroups instance can contain any number of hook groups which themselves can contain any number of hooks. A hook group would generally be created to represent a given time that hooks would occur. For instance if you had a HookGroups instance of SaveDB, you might have a \'presave\' hook group or a \'postsave\' hook group that would each contain multiple hooks to be done prior to or after a save to the database.\r\n\r\nAn individual hook is pushed to a specific hook group. For instance, with our SaveDB example above, if certain data wanted to be retrieved and fiddled with prior to the DB save, it could be a hook applied to the \'presave\' hook group.\r\n\r\nWhen a hook group is run, it executes all of the functions inside that hook group (even async hooks would be run synchronously by default, but they don\'t have to).\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Creating Hooks\r\nThere are two ways to create hooks and hook groups.\r\n\r\n### .hook()\r\n**.hook(hook-group-name (String), hook-description (String), function (Anonymous Function that returns a Promise), [key (Integer)[, replace-current-key (Boolean)[, run-hook-group-synchronously (Boolean)]]])**\r\n\r\n- *hook-group-name* - (String) - Required - This is the hook group you would like to place the hook in, if there currently is no hook group with this name, it will be created.\r\n- *hook-description* - (String) - Required - This is not generally important except when using any of the getter methods (.getHooks(), .getHookGroup(), .getHook()) for displaying the hooks. As such it is best to give that hook a description that really explains what it does, for when looking at the various hooks in a hook group, a description of what it does will be helpful.\r\n- *function* - (Anonymous Function) - Required - This is the core of what you want your hook to do. Although not required for hook groups full of synchronous functions, it is best to make these return Promises. For filtering data, and some other action-type hooks, you may wish to store, or make changes to, data in the HookGroups instance\'s data property, to pass along to other hooks, if desired.\r\n- *key* - (Integer) - Optional - Default: undefined - Since the hook group is an array of hooks, you can specify which key this function will specifically fall into. If this is left out, the hook will simply be pushed to the end of the hook group.\r\n- *replace-current-key* - (Boolean) - Optional - Default: True - if *key* is set, will replace whatever hook is set at the same key. However, if set to false, this hook will be inserted into the set key but any hook in that key already, and any after, will be shifted up by one.\r\n- *run-hook-group-synchronously* - (Boolean || \'noset\' (String)) - Optional - Default: \'noset\' (String) - If \'noset\' or True, and hook group does not already exist, the hook group will be set to run synchronously. If set to false, it will be set to run asynchronously (if there are asynchronous functions in the hook group). However, if hook group is already set, then \'noset\' will keep it as is and True, will ensure the whole hook group is set to run synchronously.\r\n\r\n```javascript\r\nconst TestHooks = new Hooks();\r\nTestHooks.hook(\'testHookGroup\', \'logs message\', () => {\r\n  return new Promise((res, rej) => {\r\n    console.log(\'Hello World\');\r\n    res(\'done\');\r\n  });\r\n}, 1, true, false);\r\n```\r\nThe above example adds a hook to the key 1 in a newly made \'testHookGroup\' hook group, if there happened to be one created beforehand this will replace any hook set at the key of 1, and this will ensure that the hook group runs asynchronously.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .hookGroup()\r\n**.hook(hook-group-name (String), hook-group-array (Array)[, run-synchronously (Boolean)])**\r\n\r\n- *hook-group-name* - (String) - Required - This is the hook group you would like to place your array of hooks into, if there currently is no hook group with this name, it will be created.\r\n- *hook-group-array* (Array) - Required - This array must be formatted as an array of objects each with a description property and a fn property, which holds your hooks description and anonymous function, which *should* return a Promise, respectively. The order they appear will be the key order they will be assigned. If this hook group already exists, this *will* replace any and all hooks in the specified hook group.\r\n- *run-synchronously* - (Boolean || \'noset\' (String)) - Optional - Default: \'noset\' (String) - If \'noset\' or True, and hook group does not already exist, the hook group will be set to run synchronously. If set to false, it will be set to run asynchronously (if there are asynchronous functions in the hook group). However, if hook group is already set, then \'noset\' will keep it as is and True, will ensure the whole hook group is set to run synchronously.\r\n\r\n```javascript\r\nconst TestHooks = new Hooks();\r\nTestHooks.data.x = 5;\r\nTestHooks.hookGroup(\'testHookGroup\', [\r\n  {\r\n    description: \'logs message\',\r\n    fn: () => {\r\n\t  return new Promise((res, rej) => {\r\n\t    console.log(\'Hello World\');\r\n\t    res(\'done\');\r\n\t  });\r\n    }\r\n  },\r\n  {\r\n    description: \'adds and returns 3 + x from data property\',\r\n    fn: () => {\r\n\t  return new Promise((res, rej) => {\r\n\t\tTestHooks.data.x + 3;\r\n\t    res(\'done\');\r\n\t  });\r\n    }\r\n  }\r\n]);\r\n```\r\nThe above example will either create or replace the hook group \'testHookGroup\', additionally, if the hook group does not exist it will be set to run synchronously default, if it already exists, it will run either synchronously or asynchronously, whichever the hook group was already set to.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Running hooks\r\nRunning hooks is quite simple you just find the place in your code that you want to run your hooks and use the proper method. You will more than likely want to run a hook group, with the *.runHooks()* method within another custom made method of your HookGroups instance. Additionally, your hook groups are run and chained with .then() methods as they are built around Promises.\r\n\r\nNote that *.runHooks()* will still run fine even if calling to run a hook group that doesn\'t yet exist, this is so that a placeholder option for hooks can be placed throughout the code that other developers may hook into without altering the core code.\r\n\r\n### .runHooks()\r\n**.runHooks(hook-group (String))**\r\n\r\n- *hook-group*  - (String) - Required - The hook group that you want to run.\r\n\r\nYou can find a great example in the set up section [here](#appjs)\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Getting Hooks\r\nThe methods to get hooks can be use full for returning all of the hook groups, a single hook group, or a single hook within a hook group. They can also be returned as a beautified JSON string, or as an object.\r\n\r\n### getHook()\r\n**getHook(hook-group-name (String), key (Integer), [returnJSONString (boolean), [stringifyFunction (boolean)]])**\r\n\r\n**returns: Object || JSON String**\r\n\r\n- *hook-group-name* - (String) - Required - the name of the hook group of the hook you would like to return.\r\n- *key* - (Integer) - Required - The key of the hook in the hook group\'s array.\r\n- *returnJSONString* - (Boolean) - optional - Default: false - By default getHook() will return an object of the indicated hook. However, if set to true, it will stringify (beautified) the hook. If set to true, a "false property" of key, will be added to the stringified hook. Keep in mind that no hooks have the "key" property, it is just there to have an easy glance at what key each hook is, and only occurs if this parameter is set to true.\r\n- *stringifyFunction* - (Boolean) - optional - Default: false - Requires: returnJSONString = true - By default, if returning a JSON string, the functions in the hook will be converted to the string: \'[Function]\'. However, if set to true, the function will be stringified and displayed as well.\r\n\r\n```javascript\r\nconst TestHooks = new Hooks();\r\nTestHooks.hook(\'testGroup\', \'log hello world\', () => {\r\n  return new Promise((res, rej) => {\r\n    console.log(\'Hello World!\');\r\n    res(\'done\');\r\n  });\r\n}, 3);\r\nconst hook = TestHooks.getHook(\'testGroup\', 3);\r\nconsole.log(hook);\r\n```\r\nThis is what would be logged to the console:\r\n\r\n```javascript\r\n{ description: \'log hello world\', fn: [Function] }\r\n```\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### getHookGroup()\r\n**getHookGroup(hook-group-name (String), [returnJSONString (boolean), [stringifyFunction (boolean)]])**\r\n\r\n**returns: Object || JSON String**\r\n\r\n- *hook-group-name* - (String) - Required - the name of the hook group you would like to return.\r\n- *returnJSONString* - (Boolean) - optional - Default: false - By default getHookGroup() will return an object of the indicated hook group. However, if set to true, it will stringify (beautified) the hook group. If set to true, the name of the hook group will have either "(Sync)" or "(Async)" appended to name, this is not actually part of the name but it is placed there so you will know how the hook group will run at a glance. Additionally, a "false property" of key, will be added to the stringified hooks. Keep in mind that no hooks have the "key" property, it is just there to have an easy glance at what key each hook is, and only occurs if this parameter is set to true.\r\n- *stringifyFunction* - (Boolean) - optional - Default: false - Requires: returnJSONString = true - By default, if returning a JSON string, the functions in the hooks will be converted to the string: \'[Function]\'. However, if set to true, the function will be stringified and displayed as well.\r\n\r\n```javascript\r\nconst TestHooks = new Hooks();\r\nTestHooks.hookGroup(\'pre\', [\r\n  {\r\n    description: \'logs message\',\r\n    fn: () => {\r\n      return new Promise((res, rej) => {\r\n        console.log(\'Hello World\');\r\n        res(\'done\');\r\n      });\r\n    }\r\n  },\r\n  {\r\n    description: \'logs second message\',\r\n    fn: () => {\r\n      return new Promise((res, rej) => {\r\n        console.log(\'Another Test Message\');\r\n        res(\'done\');\r\n      });\r\n    }\r\n  }\r\n], false);\r\nconst theHookGroup = TestHooks.getHookGroup(\'pre\', true);\r\nconsole.log(theHookGroup);\r\n```\r\nThis is what would be logged to the console:\r\n\r\n```javascript\r\n{\r\n  "pre (Async)": [\r\n    {\r\n      "description": "logs message",\r\n      "fn": "[Function]",\r\n      "key": 0\r\n    },\r\n    {\r\n      "description": "logs second message",\r\n      "fn": "[Function]",\r\n      "key": 1\r\n    }\r\n  ]\r\n}\r\n```\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### getHooks()\r\n**getHooks([returnJSONString (boolean), [stringifyFunction (boolean)]])**\r\n\r\n**returns: Object || JSON String**\r\n\r\n- *returnJSONString* - (Boolean) - optional - Default: false - By default getHooks() will return an object of the hook groups. However, if set to true, it will stringify (beautified) the hook groups. If set to true, the name of the hook groups will have either "(Sync)" or "(Async)" appended to them, this is not actually part of the name but it is placed there so you will know how the hook group will run at a glance. Additionally, a "false property" of key, will be added to the stringified hooks. Keep in mind that no hooks have the "key" property, it is just there to have an easy glance at what key each hook is, and only occurs if this parameter is set to true.\r\n- *stringifyFunction* - (Boolean) - optional - Default: false - Requires: returnJSONString = true - By default, if returning a JSON string, the functions in the hooks will be converted to the string: \'[Function]\'. However, if set to true, the function will be stringified and displayed as well.\r\n\r\n```javascript\r\nconst TestHooks = new Hooks();\r\nTestHooks.hookGroup(\'pre\', [\r\n  {\r\n    description: \'logs message\',\r\n    fn: () => {\r\n      return new Promise((res, rej) => {\r\n        console.log(\'Hello World\');\r\n        res(\'done\');\r\n      });\r\n    }\r\n  },\r\n  {\r\n    description: \'logs second message\',\r\n    fn: () => {\r\n      return new Promise((res, rej) => {\r\n        console.log(\'Another Test Message\');\r\n        res(\'done\');\r\n      });\r\n    }\r\n  }\r\n]);\r\nTestHooks.hook(\'post\', \'logs last message\', () => {\r\n  return new Promise((res, rej) => {\r\n  console.log(\'Goodbye Cruel World!\');\r\n    res(\'done\');\r\n  });\r\n})\r\nconst theHooks = TestHooks.getHooks(true, true);\r\nconsole.log(theHooks);\r\n```\r\nThis is what would be logged to the console:\r\n\r\n```\r\n{\r\n  "pre (Sync)": [\r\n    {\r\n      "description": "logs message",\r\n      "fn": "() => {\\n      return new Promise((res, rej) => {\\n        console.log(\'Hello World\');\\n        res(\'done\');\\n      });\\n    }",\r\n      "key": 0\r\n    },\r\n    {\r\n      "description": "logs second message",\r\n      "fn": "() => {\\n      return new Promise((res, rej) => {\\n        console.log(\'Another Test Message\');\\n        res(\'done\');\\n      });\\n    }",\r\n      "key": 1\r\n    }\r\n  ],\r\n  "post (Sync)": [\r\n    {\r\n      "description": "logs last message",\r\n      "fn": "() => {\\n  return new Promise((res, rej) => {\\n  console.log(\'Goodbye Cruel World!\');\\n    res(\'done\');\\n  });\\n}",\r\n      "key": 0\r\n    }\r\n  ]\r\n}\r\n```\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Removing Hooks\r\nThe following methods will remove hooks. Many times there may be hooks made throughout multiple files and/or the object may use the hook groups multiple times and the option to remove hooks along the way may be required for the focus of your app.\r\n\r\n### .unhook()\r\n**unhook(group-name (String), key (Integer))**\r\n\r\n- *group-name* - (String) - Required - the name of the hook group of the hook that you would like to remove.\r\n- *key* - (Integer) - Required - the key of the hook, in it\'s hook group, that you would like to remove.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .unhookGroup()\r\n**unhookAll(group-name (String))**\r\n\r\n- *group-name* - (String) - Required - the name of the hook group that you would like to clear. Note that this will not *actually* remove the hook group, but rather it will make the hook group empty.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .unhookAll()\r\n**unhookAll()**\r\n\r\nThis method has no parameters and will completely clear out all hooks and hook groups to a clean slate. Note that the hook groups will no longer exist, although, a runHooks() will still run fine and should not break the app, even if calling upon a hook group that does not exist.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Cloning Hooks\r\nSometimes the hooks and hook groups may be needed in various instances, but you won\'t have to create them all over again. You can clone hooks and hook groups into a new hook group or an existing one.\r\n\r\n### .cloneHook()\r\n**cloneHook(fromGroup (String), fromKey (Integer), toGroup (String), toKey (Integer), replace(Boolean))**\r\n\r\n- *fromGroup* - String - Required - the hook group of the hook you want to clone\r\n- *fromKey* - Integer - Required - the hook\'s key that you want to clone\r\n- *toGroup* - String - Required - the hook group that you want the hook to clone to. If this hook group does not yet exist, it will be created fro you.\r\n- *toKey* - Integer - Required - the key in the hook group you want to clone the hook to.\r\n- *replace* - Boolean - Required - Whether or not you want to replace any hook already in the key of the hook group you want to clone to. If set to false, the hook that pre-exists in that key, and all hooks after, will be shifted up by one.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .cloneHookGroup()\r\n**cloneHookGroup(fromGroup (String), toGroup (String), replace(Boolean))**\r\n\r\n- *fromGroup* - String - Required - the hook group you want to clone\r\n- *toGroup* - String - Required - the hook group you want to clone to. If it does not currently exist it will be created for you.\r\n- *replace* - Boolean - Required - Whether or not you want to completely replace the hook group you are cloning to with the hook group you are cloning. If false, it will concatenate the cloning hook group to the end.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n## Altering Hooks\r\nMuch like in the case of needed to remove hooks and hook groups, many times you may need to rearrange them i various situations, or change whether they run synchronously/asynchronously, or you may want to clean up hook groups with empty keys.\r\n\r\n### moveHook()\r\nAllows you to move a hook from one place to another. If you are planning on switching the \'location\' of two different hooks it is recommended to use .swapHooks() instead.\r\n\r\nNote: using this method will clean up the applicable hook group(s), i.e. will remove empty keys, after the moving has occurred.\r\n\r\n**moveHook(fromGroup (String), fromKey (Integer), toGroup (String), toKey (Integer), replace (Boolean))**\r\n\r\n- *fromGroup* - String - Required - the hook group in which the hook exists before the move.\r\n- *fromKey* - Integer - Required - the key of the hook before the move\r\n- *toGroup* - String - Required - the hook group to which the hook will be moved to, this can be the same as *fromGroup*.\r\n- *toKey* - Integer - Required - the key of the *toGroup* that you want to move the hook to.\r\n- *replace* - Boolean - Required - Whether or not you want to replace any hook that may exist in your *toGroup* that has the key of *toKey*. If set to false, the hook that was already there, and all hooks after it, will be shifted up by one.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .swapHooks()\r\nAllows you to switch the position of 2 hooks either within the same hook group or between two hook groups.\r\n\r\nNote: using this method will clean up the applicable hook group(s), i.e. will remove empty keys, after the swapping has occurred.\r\n\r\n**swapHooks(fromGroup, fromKey, toGroup, toKey)**\r\n\r\n- *fromGroup* - String - Required - the hook group in which the first hook exists before the swap.\r\n- *fromKey* - Integer - Required - the key of the first hook before the swap\r\n- *toGroup* - String - Required - the hook group in which the second hook exists before the swap. this may be the same as *fromGroup*\r\n- *toKey* - Integer - Required - the key of the second hook before the swap\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .hookGroupSync()\r\nThis method simply allows you to change whether a hook group runs all of its hooks synchronously or asynchronously.\r\n\r\n**hookGroupSync(groupName (String)[, runSync (Boolean)])**\r\n\r\n- *groupName* - String - Required - The hook group that you want to change\r\n- *runSync* - Boolean - Optional - Default: True - Whether or not you want the hook group its hooks synchronously.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .cleanHookGroup()\r\nRemoves empty keys from a hook group. Note: this may change some of the current hooks\' keys.\r\n\r\n**cleanHookGroup(groupName (String))**\r\n\r\n- *groupName* - String - Required -  the hook group that you want to remove the empty keys from.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n\r\n### .cleanHooks()\r\nRemoves all empty keys from all hook groups or a specified array of hook groups.\r\n\r\n**cleanHooks(hookGroups (String | Array of Strings))**\r\n\r\n- *hookGroups* - Sting or Array of Strings - Optional - Default: undefined - Accepts a single string of a specified hook group, an array of specified hook groups. This will remove empty keys from all of the specified hooks. If left undefined, it will clean every hook group.\r\n\r\n[Back to Table of Contents](#table-of-contents)\r\n',
23 silly publish   readmeFilename: 'README.md',
23 silly publish   gitHead: '609aac50407bbf77f5d14986165a6c96d944b6f2',
23 silly publish   _id: 'hooks@0.1.0',
23 silly publish   _shasum: '705cd176acb88b9350255a0e9b56680c642f2762',
23 silly publish   _from: '.' }
24 verbose getPublishConfig undefined
25 silly mapToRegistry name hooks
26 silly mapToRegistry using default registry
27 silly mapToRegistry registry https://registry.npmjs.org/
28 silly mapToRegistry data Result {
28 silly mapToRegistry   raw: 'hooks',
28 silly mapToRegistry   scope: null,
28 silly mapToRegistry   escapedName: 'hooks',
28 silly mapToRegistry   name: 'hooks',
28 silly mapToRegistry   rawSpec: '',
28 silly mapToRegistry   spec: 'latest',
28 silly mapToRegistry   type: 'tag' }
29 silly mapToRegistry uri https://registry.npmjs.org/hooks
30 verbose publish registryBase https://registry.npmjs.org/
31 silly publish uploading C:\Users\Mark Dekin\AppData\Roaming\npm-cache\hooks\0.1.0\package.tgz
32 verbose request uri https://registry.npmjs.org/hooks
33 verbose request sending authorization for write operation
34 info attempt registry request try #1 at 7:38:36 PM
35 verbose request using bearer token for auth
36 verbose request id 771348ff7ccd6a74
37 http request PUT https://registry.npmjs.org/hooks
38 http 403 https://registry.npmjs.org/hooks
39 verbose headers { 'content-type': 'application/json',
39 verbose headers   'cache-control': 'max-age=300',
39 verbose headers   'content-length': '99',
39 verbose headers   'accept-ranges': 'bytes',
39 verbose headers   date: 'Wed, 01 Nov 2017 23:38:37 GMT',
39 verbose headers   via: '1.1 varnish',
39 verbose headers   connection: 'keep-alive',
39 verbose headers   'x-served-by': 'cache-dca17746-DCA',
39 verbose headers   'x-cache': 'MISS',
39 verbose headers   'x-cache-hits': '0',
39 verbose headers   'x-timer': 'S1509579517.053310,VS0,VE348',
39 verbose headers   vary: 'Accept-Encoding, Accept' }
40 verbose request invalidating C:\Users\Mark Dekin\AppData\Roaming\npm-cache\registry.npmjs.org\hooks on PUT
41 error publish Failed PUT 403
42 verbose stack Error: You do not have permission to publish "hooks". Are you logged in as the correct user? : hooks
42 verbose stack     at makeError (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:302:12)
42 verbose stack     at CachingRegistryClient.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:290:14)
42 verbose stack     at Request._callback (C:\Program Files\nodejs\node_modules\npm\node_modules\npm-registry-client\lib\request.js:210:14)
42 verbose stack     at Request.self.callback (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:187:22)
42 verbose stack     at emitTwo (events.js:106:13)
42 verbose stack     at Request.emit (events.js:191:7)
42 verbose stack     at Request.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:1048:10)
42 verbose stack     at emitOne (events.js:96:13)
42 verbose stack     at Request.emit (events.js:188:7)
42 verbose stack     at IncomingMessage.<anonymous> (C:\Program Files\nodejs\node_modules\npm\node_modules\request\request.js:969:12)
43 verbose statusCode 403
44 verbose pkgid hooks
45 verbose cwd D:\dev\node_modules\hooks
46 error Windows_NT 10.0.15063
47 error argv "C:\\Program Files\\nodejs\\node.exe" "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "publish"
48 error node v6.11.5
49 error npm  v3.10.10
50 error code E403
51 error You do not have permission to publish "hooks". Are you logged in as the correct user? : hooks
52 error If you need help, you may report this error at:
52 error     <https://github.com/npm/npm/issues>
53 verbose exit [ 1, true ]
